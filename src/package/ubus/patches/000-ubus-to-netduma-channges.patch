diff -ruN a/cli.c b/cli.c
--- a/cli.c	2017-02-20 05:32:19.000000000 -0500
+++ b/cli.c	2017-09-08 07:08:41.000000000 -0400
@@ -17,7 +17,6 @@
 #include "libubus.h"
 
 static struct blob_buf b;
-static int listen_timeout;
 static int timeout = 30;
 static bool simple_output = false;
 static int verbose = 0;
@@ -95,7 +94,8 @@
 	free(str);
 }
 
-static void print_event(const char *type, struct blob_attr *msg)
+static void receive_event(struct ubus_context *ctx, struct ubus_event_handler *ev,
+			  const char *type, struct blob_attr *msg)
 {
 	char *str;
 
@@ -105,20 +105,6 @@
 	free(str);
 }
 
-static int receive_request(struct ubus_context *ctx, struct ubus_object *obj,
-			    struct ubus_request_data *req,
-			    const char *method, struct blob_attr *msg)
-{
-	print_event(method, msg);
-	return 0;
-}
-
-static void receive_event(struct ubus_context *ctx, struct ubus_event_handler *ev,
-			  const char *type, struct blob_attr *msg)
-{
-	print_event(type, msg);
-}
-
 static int ubus_cli_list(struct ubus_context *ctx, int argc, char **argv)
 {
 	const char *path = NULL;
@@ -156,34 +142,24 @@
 
 struct cli_listen_data {
 	struct uloop_timeout timeout;
+	struct ubus_event_handler ev;
 	bool timed_out;
 };
 
-static void ubus_cli_listen_timeout(struct uloop_timeout *timeout)
+static void listen_timeout(struct uloop_timeout *timeout)
 {
 	struct cli_listen_data *data = container_of(timeout, struct cli_listen_data, timeout);
 	data->timed_out = true;
 	uloop_end();
 }
 
-static void do_listen(struct ubus_context *ctx, struct cli_listen_data *data)
-{
-	memset(data, 0, sizeof(*data));
-	data->timeout.cb = ubus_cli_listen_timeout;
-	uloop_init();
-	ubus_add_uloop(ctx);
-	if (listen_timeout)
-		uloop_timeout_set(&data->timeout, listen_timeout * 1000);
-	uloop_run();
-	uloop_done();
-}
-
 static int ubus_cli_listen(struct ubus_context *ctx, int argc, char **argv)
 {
-	struct ubus_event_handler ev = {
-		.cb = receive_event,
+	struct cli_listen_data data = {
+		.timeout.cb = listen_timeout,
+		.ev.cb = receive_event,
+		.timed_out = false,
 	};
-	struct cli_listen_data data;
 	const char *event;
 	int ret = 0;
 
@@ -195,7 +171,7 @@
 	}
 
 	do {
-		ret = ubus_register_event_handler(ctx, &ev, event);
+		ret = ubus_register_event_handler(ctx, &data.ev, event);
 		if (ret)
 			break;
 
@@ -214,52 +190,15 @@
 		return -1;
 	}
 
-	do_listen(ctx, &data);
-
-	return 0;
-}
-
-static int ubus_cli_subscribe(struct ubus_context *ctx, int argc, char **argv)
-{
-	struct ubus_subscriber sub = {
-		.cb = receive_request,
-	};
-	struct cli_listen_data data;
-	const char *event;
-	int ret = 0;
-
-	if (argc > 0) {
-		event = argv[0];
-	} else {
-		if (!simple_output)
-			fprintf(stderr, "You need to specify an object to subscribe to\n");
-		return -1;
-	}
-
-	ret = ubus_register_subscriber(ctx, &sub);
-	for (; !ret && argc > 0; argc--, argv++) {
-		uint32_t id;
-
-		ret = ubus_lookup_id(ctx, argv[0], &id);
-		if (ret)
-			break;
-
-		ret = ubus_subscribe(ctx, &sub, id);
-	}
-
-	if (ret) {
-		if (!simple_output)
-			fprintf(stderr, "Error while registering for event '%s': %s\n",
-				event, ubus_strerror(ret));
-		return -1;
-	}
-
-	do_listen(ctx, &data);
+	uloop_init();
+	ubus_add_uloop(ctx);
+	uloop_timeout_set(&data.timeout, timeout * 1000);
+	uloop_run();
+	uloop_done();
 
 	return 0;
 }
 
-
 static int ubus_cli_send(struct ubus_context *ctx, int argc, char **argv)
 {
 	if (argc < 1 || argc > 2)
@@ -354,20 +293,17 @@
 	uloop_init();
 	ubus_add_uloop(ctx);
 
-	ret = ubus_register_event_handler(ctx, &data.ev, "ubus.object.add");
+	ret = ubus_lookup(ctx, NULL, wait_list_cb, &data);
 	if (ret)
 		return ret;
 
 	if (!data.n_pending)
 		return ret;
 
-	ret = ubus_lookup(ctx, NULL, wait_list_cb, &data);
+	ret = ubus_register_event_handler(ctx, &data.ev, "ubus.object.add");
 	if (ret)
 		return ret;
 
-	if (!data.n_pending)
-		return ret;
-
 	uloop_timeout_set(&data.timeout, timeout * 1000);
 	uloop_run();
 	uloop_done();
@@ -565,7 +501,6 @@
 	{ "list", ubus_cli_list },
 	{ "call", ubus_cli_call },
 	{ "listen", ubus_cli_listen },
-	{ "subscribe", ubus_cli_subscribe },
 	{ "send", ubus_cli_send },
 	{ "wait_for", ubus_cli_wait_for },
 	{ "monitor", ubus_cli_monitor },
@@ -587,7 +522,6 @@
 			ubus_socket = optarg;
 			break;
 		case 't':
-			listen_timeout = atoi(optarg);
 			timeout = atoi(optarg);
 			break;
 		case 'S':
diff -ruN a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt	2017-02-20 05:32:19.000000000 -0500
+++ b/CMakeLists.txt	2017-09-08 07:08:41.000000000 -0400
@@ -13,6 +13,11 @@
 ADD_DEFINITIONS( -DUBUS_UNIX_SOCKET="${UBUS_UNIX_SOCKET}")
 ADD_DEFINITIONS( -DUBUS_MAX_MSGLEN=${UBUS_MAX_MSGLEN})
 
+IF(APPLE)
+  INCLUDE_DIRECTORIES(/opt/local/include)
+  LINK_DIRECTORIES(/opt/local/lib)
+ENDIF()
+
 IF(BUILD_STATIC)
   FIND_LIBRARY(ubox_library NAMES ubox.a)
   FIND_LIBRARY(blob_library NAMES blobmsg_json.a)
@@ -27,11 +32,10 @@
 ADD_LIBRARY(ubus SHARED libubus.c libubus-io.c libubus-obj.c libubus-sub.c libubus-req.c libubus-acl.c)
 TARGET_LINK_LIBRARIES(ubus ${ubox_library})
 
-find_library(json NAMES json-c json)
-
 ADD_EXECUTABLE(ubusd ubusd.c ubusd_id.c ubusd_obj.c ubusd_proto.c ubusd_event.c ubusd_acl.c ubusd_monitor.c)
 TARGET_LINK_LIBRARIES(ubusd ${ubox_library} ${blob_library} ${json})
 
+find_library(json NAMES json-c json)
 ADD_EXECUTABLE(cli cli.c)
 SET_TARGET_PROPERTIES(cli PROPERTIES OUTPUT_NAME ubus)
 TARGET_LINK_LIBRARIES(cli ubus ${ubox_library} ${blob_library} ${json})
diff -ruN a/examples/CMakeLists.txt b/examples/CMakeLists.txt
--- a/examples/CMakeLists.txt	2017-02-20 05:32:19.000000000 -0500
+++ b/examples/CMakeLists.txt	2017-09-08 07:08:41.000000000 -0400
@@ -5,7 +5,7 @@
 
 IF (BUILD_EXAMPLES)
 	ADD_EXECUTABLE(server server.c count.c)
-	TARGET_LINK_LIBRARIES(server ubus ${ubox_library} ${blob_library} ${json})
+	TARGET_LINK_LIBRARIES(server ubus ${ubox_library} ${blob_library})
 
 	ADD_EXECUTABLE(client client.c count.c)
 	TARGET_LINK_LIBRARIES(client ubus ${ubox_library})
diff -ruN a/.gitignore b/.gitignore
--- a/.gitignore	2017-02-20 05:32:19.000000000 -0500
+++ b/.gitignore	1969-12-31 19:00:00.000000000 -0500
@@ -1,12 +0,0 @@
-Makefile
-CMakeCache.txt
-CMakeFiles
-*.cmake
-*.a
-*.so
-*.dylib
-examples/server
-examples/client
-ubusd
-ubus
-install_manifest.txt
diff -ruN a/libubus.c b/libubus.c
--- a/libubus.c	2017-02-20 05:32:19.000000000 -0500
+++ b/libubus.c	2017-09-08 07:08:41.000000000 -0400
@@ -277,7 +277,6 @@
 
 int ubus_connect_ctx(struct ubus_context *ctx, const char *path)
 {
-	uloop_init();
 	memset(ctx, 0, sizeof(*ctx));
 
 	ctx->sock.fd = -1;
@@ -363,7 +362,6 @@
 	if (!ctx)
 		return;
 	close(ctx->sock.fd);
-	uloop_timeout_cancel(&ctx->pending_timer);
 	free(ctx->msgbuf.data);
 }
 
diff -ruN a/libubus.h b/libubus.h
--- a/libubus.h	2017-02-20 05:32:19.000000000 -0500
+++ b/libubus.h	2017-09-08 07:08:41.000000000 -0400
@@ -155,7 +155,6 @@
 
 	uint32_t local_id;
 	uint16_t request_seq;
-	bool cancel_poll;
 	int stack_depth;
 
 	void (*connection_lost)(struct ubus_context *ctx);
@@ -332,26 +331,21 @@
 /* ----------- rpc ----------- */
 
 /* invoke a method on a specific object */
+int ubus_invoke(struct ubus_context *ctx, uint32_t obj, const char *method,
+		struct blob_attr *msg, ubus_data_handler_t cb, void *priv,
+		int timeout);
+
+/* asynchronous version of ubus_invoke() */
+int ubus_invoke_async(struct ubus_context *ctx, uint32_t obj, const char *method,
+		      struct blob_attr *msg, struct ubus_request *req);
+
 int ubus_invoke_fd(struct ubus_context *ctx, uint32_t obj, const char *method,
 		struct blob_attr *msg, ubus_data_handler_t cb, void *priv,
 		int timeout, int fd);
-static inline int
-ubus_invoke(struct ubus_context *ctx, uint32_t obj, const char *method,
-	    struct blob_attr *msg, ubus_data_handler_t cb, void *priv,
-	    int timeout)
-{
-	return ubus_invoke_fd(ctx, obj, method, msg, cb, priv, timeout, -1);
-}
 
 /* asynchronous version of ubus_invoke() */
 int ubus_invoke_async_fd(struct ubus_context *ctx, uint32_t obj, const char *method,
 		      struct blob_attr *msg, struct ubus_request *req, int fd);
-static inline int
-ubus_invoke_async(struct ubus_context *ctx, uint32_t obj, const char *method,
-		  struct blob_attr *msg, struct ubus_request *req)
-{
-	return ubus_invoke_async_fd(ctx, obj, method, msg, req, -1);
-}
 
 /* send a reply to an incoming object method call */
 int ubus_send_reply(struct ubus_context *ctx, struct ubus_request_data *req,
diff -ruN a/libubus-io.c b/libubus-io.c
--- a/libubus-io.c	2017-02-20 05:32:19.000000000 -0500
+++ b/libubus-io.c	2017-09-08 07:08:41.000000000 -0400
@@ -154,10 +154,9 @@
 	return ret;
 }
 
-static int recv_retry(struct ubus_context *ctx, struct iovec *iov, bool wait, int *recv_fd)
+static int recv_retry(int fd, struct iovec *iov, bool wait, int *recv_fd)
 {
 	int bytes, total = 0;
-	int fd = ctx->sock.fd;
 	static struct {
 		struct cmsghdr h;
 		int fd;
@@ -192,7 +191,7 @@
 
 		if (bytes < 0) {
 			bytes = 0;
-			if (uloop_cancelling() || ctx->cancel_poll)
+			if (uloop_cancelled)
 				return 0;
 			if (errno == EINTR)
 				continue;
@@ -260,7 +259,6 @@
 		return false;
 
 	ctx->msgbuf.data = ptr;
-	ctx->msgbuf_data_len = len;
 	return true;
 }
 
@@ -275,7 +273,7 @@
 	int r;
 
 	/* receive header + start attribute */
-	r = recv_retry(ctx, &iov, false, recv_fd);
+	r = recv_retry(ctx->sock.fd, &iov, false, recv_fd);
 	if (r <= 0) {
 		if (r < 0)
 			ctx->sock.eof = true;
@@ -299,7 +297,7 @@
 	iov.iov_base = (char *)ctx->msgbuf.data + sizeof(hdrbuf.data);
 	iov.iov_len = blob_len(ctx->msgbuf.data);
 	if (iov.iov_len > 0 &&
-	    recv_retry(ctx, &iov, true, NULL) <= 0)
+	    recv_retry(ctx->sock.fd, &iov, true, NULL) <= 0)
 		return false;
 
 	return true;
@@ -312,7 +310,7 @@
 
 	while (get_next_msg(ctx, &recv_fd)) {
 		ubus_process_msg(ctx, &ctx->msgbuf, recv_fd);
-		if (uloop_cancelling() || ctx->cancel_poll)
+		if (uloop_cancelled)
 			break;
 	}
 
@@ -327,7 +325,6 @@
 		.events = POLLIN | POLLERR,
 	};
 
-	ctx->cancel_poll = false;
 	poll(&pfd, 1, timeout ? timeout : -1);
 	ubus_handle_data(&ctx->sock, ULOOP_READ);
 }
@@ -374,8 +371,6 @@
 		close(ctx->sock.fd);
 	}
 
-	ctx->sock.eof = false;
-	ctx->sock.error = false;
 	ctx->sock.fd = usock(USOCK_UNIX, path, NULL);
 	if (ctx->sock.fd < 0)
 		return UBUS_STATUS_CONNECTION_FAILED;
diff -ruN a/libubus-req.c b/libubus-req.c
--- a/libubus-req.c	2017-02-20 05:32:19.000000000 -0500
+++ b/libubus-req.c	2017-09-08 07:08:41.000000000 -0400
@@ -122,7 +122,7 @@
 {
 	req->status_msg = true;
 	req->status_code = ret;
-	req->ctx->cancel_poll = true;
+	uloop_end();
 }
 
 static int64_t get_time_msec(void)
@@ -140,9 +140,15 @@
 			  int req_timeout)
 {
 	ubus_complete_handler_t complete_cb = req->complete_cb;
+	bool registered = ctx->sock.registered;
 	int status = UBUS_STATUS_NO_DATA;
 	int64_t timeout = 0, time_end = 0;
 
+	if (!registered) {
+		uloop_init();
+		ubus_add_uloop(ctx);
+	}
+
 	if (req_timeout)
 		time_end = get_time_msec() + req_timeout;
 
@@ -151,26 +157,28 @@
 
 	ctx->stack_depth++;
 	while (!req->status_msg) {
+		bool cancelled = uloop_cancelled;
+
+		uloop_cancelled = false;
 		if (req_timeout) {
 			timeout = time_end - get_time_msec();
 			if (timeout <= 0) {
 				ubus_set_req_status(req, UBUS_STATUS_TIMEOUT);
+				uloop_cancelled = cancelled;
 				break;
 			}
 		}
-
 		ubus_poll_data(ctx, (unsigned int) timeout);
 
+		uloop_cancelled = cancelled;
 		if (ctx->sock.eof) {
 			ubus_set_req_status(req, UBUS_STATUS_CONNECTION_FAILED);
-			ctx->cancel_poll = true;
 			break;
 		}
 	}
-
 	ctx->stack_depth--;
 	if (ctx->stack_depth)
-		ctx->cancel_poll = true;
+		uloop_cancelled = true;
 
 	if (req->status_msg)
 		status = req->status_code;
@@ -179,8 +187,12 @@
 	if (req->complete_cb)
 		req->complete_cb(req, status);
 
-	if (!ctx->stack_depth && !ctx->sock.registered)
-		ctx->pending_timer.cb(&ctx->pending_timer);
+	if (!registered) {
+		uloop_fd_delete(&ctx->sock);
+
+		if (!ctx->stack_depth)
+			ctx->pending_timer.cb(&ctx->pending_timer);
+	}
 
 	return status;
 }
@@ -208,9 +220,24 @@
 	return 0;
 }
 
-int ubus_invoke_async_fd(struct ubus_context *ctx, uint32_t obj,
-			 const char *method, struct blob_attr *msg,
-			 struct ubus_request *req, int fd)
+int ubus_invoke_async(struct ubus_context *ctx, uint32_t obj, const char *method,
+                       struct blob_attr *msg, struct ubus_request *req)
+{
+	blob_buf_init(&b, 0);
+	blob_put_int32(&b, UBUS_ATTR_OBJID, obj);
+	blob_put_string(&b, UBUS_ATTR_METHOD, method);
+	if (msg)
+		blob_put(&b, UBUS_ATTR_DATA, blob_data(msg), blob_len(msg));
+
+	if (ubus_start_request(ctx, req, b.head, UBUS_MSG_INVOKE, obj) < 0)
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	return 0;
+}
+
+
+int ubus_invoke_async_fd(struct ubus_context *ctx, uint32_t obj, const char *method,
+                       struct blob_attr *msg, struct ubus_request *req, int fd)
 {
 	blob_buf_init(&b, 0);
 	blob_put_int32(&b, UBUS_ATTR_OBJID, obj);
@@ -225,9 +252,25 @@
 	return 0;
 }
 
+int ubus_invoke(struct ubus_context *ctx, uint32_t obj, const char *method,
+                struct blob_attr *msg, ubus_data_handler_t cb, void *priv,
+		int timeout)
+{
+	struct ubus_request req;
+	int rc;
+
+	rc = ubus_invoke_async(ctx, obj, method, msg, &req);
+	if (rc)
+		return rc;
+
+	req.data_cb = cb;
+	req.priv = priv;
+	return ubus_complete_request(ctx, &req, timeout);
+}
+
 int ubus_invoke_fd(struct ubus_context *ctx, uint32_t obj, const char *method,
-		   struct blob_attr *msg, ubus_data_handler_t cb, void *priv,
-		   int timeout, int fd)
+                struct blob_attr *msg, ubus_data_handler_t cb, void *priv,
+		int timeout, int fd)
 {
 	struct ubus_request req;
 	int rc;
diff -ruN a/lua/test.lua b/lua/test.lua
--- a/lua/test.lua	2017-02-20 05:32:19.000000000 -0500
+++ b/lua/test.lua	2017-09-08 07:08:41.000000000 -0400
@@ -34,18 +34,6 @@
 				conn:reply(req, {message="foo2"});
 				print("Call to function 'hello1'")
 			end, {id = ubus.INT32, msg = ubus.STRING }
-		},
-		deferred = {
-			function(req)
-				conn:reply(req, {message="wait for it"})
-				local def_req = conn:defer_request(req)
-				uloop.timer(function()
-						conn:reply(def_req, {message="done"})
-						conn:complete_deferred_request(def_req, 0)
-						print("Deferred request complete")
-					end, 2000)
-				print("Call to function 'deferred'")
-			end, {}
 		}
 	}
 }
diff -ruN a/lua/ubus.c b/lua/ubus.c
--- a/lua/ubus.c	2017-02-20 05:32:19.000000000 -0500
+++ b/lua/ubus.c	2017-09-08 07:08:41.000000000 -0400
@@ -307,7 +307,8 @@
 			lua_pushnil(state);
 		else
 			ubus_lua_parse_blob_array(state, blob_data(msg), blob_len(msg), true);
-		lua_call(state, 2, 1);
+		lua_pushnumber(state,req->req_fd);
+		lua_call(state, 3, 1);
 		if (lua_isnumber(state, -1))
 			rv = lua_tonumber(state, -1);
 	}
@@ -352,26 +353,6 @@
 	return 0;
 }
 
-static int ubus_lua_defer_request(lua_State *L)
-{
-	struct ubus_lua_connection *c = luaL_checkudata(L, 1, METANAME);
-	struct ubus_request_data *req = lua_touserdata(L, 2);
-	struct ubus_request_data *new_req = lua_newuserdata(L, sizeof(struct ubus_request_data));
-	ubus_defer_request(c->ctx, req, new_req);
-
-	return 1;
-}
-
-static int ubus_lua_complete_deferred_request(lua_State *L)
-{
-	struct ubus_lua_connection *c = luaL_checkudata(L, 1, METANAME);
-	struct ubus_request_data *req = lua_touserdata(L, 2);
-	int ret = luaL_checkinteger(L, 3);
-	ubus_complete_deferred_request(c->ctx, req, ret);
-
-	return 0;
-}
-
 static int ubus_lua_load_methods(lua_State *L, struct ubus_method *m)
 {
 	struct blobmsg_policy *p;
@@ -658,6 +639,11 @@
 	struct ubus_lua_connection *c = luaL_checkudata(L, 1, METANAME);
 	const char *path = luaL_checkstring(L, 2);
 	const char *func = luaL_checkstring(L, 3);
+        int fd = -1;
+	if( lua_isnumber(L,5) ){
+		fd = lua_tointeger(L,5);
+		lua_pushvalue( L, 4 );
+	}
 
 	luaL_checktype(L, 4, LUA_TTABLE);
 	blob_buf_init(&c->buf, 0);
@@ -679,7 +665,7 @@
 	}
 
 	top = lua_gettop(L);
-	rv = ubus_invoke(c->ctx, id, func, c->buf.head, ubus_lua_call_cb, L, c->timeout * 1000);
+	rv = ubus_invoke_fd(c->ctx, id, func, c->buf.head, ubus_lua_call_cb, L, c->timeout * 1000, fd);
 
 	if (rv != UBUS_STATUS_OK)
 	{
@@ -704,7 +690,8 @@
 
 	if (lua_isfunction(state, -1)) {
 		ubus_lua_parse_blob_array(state, blob_data(msg), blob_len(msg), true);
-		lua_call(state, 1, 0);
+		lua_pushstring(state, type);
+		lua_call(state, 2, 0);
 	} else {
 		lua_pop(state, 1);
 	}
@@ -790,11 +777,12 @@
 	lua_remove(state, -2);
 
 	if (lua_isfunction(state, -1)) {
+		lua_pushstring(state, method);
 		if( msg ){
 			ubus_lua_parse_blob_array(state, blob_data(msg), blob_len(msg), true);
-			lua_call(state, 1, 0);
+			lua_call(state, 2, 0);
 		} else {
-			lua_call(state, 0, 0);
+			lua_call(state, 1, 0);
 		}
 	} else {
 		lua_pop(state, 1);
@@ -940,8 +928,6 @@
 	{ "add", ubus_lua_add },
 	{ "notify", ubus_lua_notify },
 	{ "reply", ubus_lua_reply },
-	{ "defer_request", ubus_lua_defer_request },
-	{ "complete_deferred_request", ubus_lua_complete_deferred_request },
 	{ "signatures", ubus_lua_signatures },
 	{ "call", ubus_lua_call },
 	{ "close", ubus_lua__gc },
diff -ruN a/ubusd_acl.c b/ubusd_acl.c
--- a/ubusd_acl.c	2017-02-20 05:32:19.000000000 -0500
+++ b/ubusd_acl.c	2017-09-08 07:08:41.000000000 -0400
@@ -101,7 +101,7 @@
 	struct blob_attr *cur;
 	int rem;
 
-	if (!cl->uid || !obj)
+	if (!cl->uid)
 		return 0;
 
 	acl = avl_find_ge_element(&ubusd_acls, obj, acl, avl);
@@ -361,7 +361,7 @@
 	void *blob;
 
 	blob_buf_init(&bbuf, 0);
-	if (!blobmsg_add_json_from_file(&bbuf, filename)) {
+	if (!blobmsg_add_json_from_file(&bbuf, (char*)filename)) {
 		syslog(LOG_ERR, "failed to parse %s\n", filename);
 		return -1;
 	}
@@ -434,7 +434,7 @@
 		if (!acl->priv)
 			continue;
 
-		if (ubusd_acl_match_path(obj->path.key, acl->avl.key, NULL))
+		if (!ubusd_acl_match_path(obj->path.key, acl->avl.key, NULL))
 			continue;
 
 		c = blobmsg_open_table(&b, NULL);
diff -ruN a/ubusd.c b/ubusd.c
--- a/ubusd.c	2017-02-20 05:32:19.000000000 -0500
+++ b/ubusd.c	2017-09-08 07:08:41.000000000 -0400
@@ -32,15 +32,8 @@
 
 static struct ubus_msg_buf *ubus_msg_ref(struct ubus_msg_buf *ub)
 {
-	struct ubus_msg_buf *new_ub;
-	if (ub->refcount == ~0) {
-		new_ub = ubus_msg_new(ub->data, ub->len, false);
-		if (!new_ub)
-			return NULL;
-		memcpy(&new_ub->hdr, &ub->hdr, sizeof(struct ubus_msghdr));
-		new_ub->fd = ub->fd;
-		return new_ub;
-	}
+	if (ub->refcount == ~0)
+		return ubus_msg_new(ub->data, ub->len, false);
 
 	ub->refcount++;
 	return ub;
@@ -155,11 +148,10 @@
 
 	if (!cl->tx_queue[cl->txq_cur]) {
 		written = ubus_msg_writev(cl->sock.fd, ub, 0);
-
 		if (written < 0)
 			written = 0;
 
-		if (written >= ub->len + sizeof(ub->hdr))
+                if (written >= ub->len + sizeof(ub->hdr))
 			goto out;
 
 		cl->txq_ofs = written;
diff -ruN a/ubusd_proto.c b/ubusd_proto.c
--- a/ubusd_proto.c	2017-02-20 05:32:19.000000000 -0500
+++ b/ubusd_proto.c	2017-09-08 07:08:41.000000000 -0400
@@ -134,8 +134,8 @@
 	if (obj->type && obj->type->refcount == 1)
 		blob_put_int32(&b, UBUS_ATTR_OBJTYPE, obj->type->id.id);
 
-	ubus_proto_send_msg_from_blob(cl, ub, UBUS_MSG_DATA);
 	ubusd_free_object(obj);
+	ubus_proto_send_msg_from_blob(cl, ub, UBUS_MSG_DATA);
 
 	return 0;
 }
@@ -150,7 +150,7 @@
 
 	blob_buf_init(&b, 0);
 	blob_put_int32(&b, UBUS_ATTR_OBJID, obj->id.id);
-	if (attr[UBUS_ATTR_SIGNATURE] && obj->type)
+	if (attr[UBUS_ATTR_SIGNATURE])
 		blob_put_int32(&b, UBUS_ATTR_OBJTYPE, obj->type->id.id);
 
 	ubus_proto_send_msg_from_blob(cl, ub, UBUS_MSG_DATA);
@@ -160,12 +160,9 @@
 static void ubusd_send_obj(struct ubus_client *cl, struct ubus_msg_buf *ub, struct ubus_object *obj)
 {
 	struct ubus_method *m;
-	int all_cnt = 0, cnt = 0;
+	int cnt = 0;
 	void *s;
 
-	if (!obj->type)
-		return;
-
 	blob_buf_init(&b, 0);
 
 	blob_put_string(&b, UBUS_ATTR_OBJPATH, obj->path.key);
@@ -174,7 +171,6 @@
 
 	s = blob_nest_start(&b, UBUS_ATTR_SIGNATURE);
 	list_for_each_entry(m, &obj->type->methods, list) {
-		all_cnt++;
 		if (!ubusd_acl_check(cl, obj->path.key, blobmsg_name(m->data), UBUS_ACL_ACCESS)) {
 			blobmsg_add_blob(&b, m->data);
 			cnt++;
@@ -182,7 +178,7 @@
 	}
 	blob_nest_end(&b, s);
 
-	if (cnt || !all_cnt)
+	if (cnt)
 		ubus_proto_send_msg_from_blob(cl, ub, UBUS_MSG_DATA);
 }
 
@@ -382,7 +378,7 @@
 		return UBUS_STATUS_INVALID_ARGUMENT;
 
 	target = ubusd_find_object(blob_get_u32(attr[UBUS_ATTR_TARGET]));
-	if (!target || !target->client)
+	if (!target)
 		return UBUS_STATUS_NOT_FOUND;
 
 	if (cl == target->client)
